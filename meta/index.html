<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Meta - Code Analysis</title>
  </head>
  <body>
    <h1>Meta: Code Analysis</h1>
    <p>
      This page displays statistics and visualizations about the codebase of this portfolio website.
      The data is generated by analyzing git commit history and current code structure.
    </p>

    <h2>Summary Statistics</h2>
    <dl id="stats" class="stats"></dl>

    <h2>Commit Timeline Scatterplot</h2>
    <svg id="commit-scatterplot"></svg>

    <div id="tooltip" class="info tooltip">
      <p>Commit: <strong id="commit-id"></strong></p>
      <p>Author: <strong id="commit-author"></strong></p>
      <p>Date: <strong id="commit-date"></strong></p>
      <p>Time: <strong id="commit-time"></strong></p>
      <p>Lines: <strong id="commit-lines"></strong></p>
    </div>

    <p id="selection-count">No commits selected</p>
    <dl id="language-breakdown" class="stats"></dl>

    <link rel="stylesheet" href="../style.css" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="../global.js" type="module"></script>
    <script type="module">
      import { fetchJSON } from '../global.js';

      // Step 1.1: Reading the CSV file in D3
      const commits = await d3.csv('loc.csv', (row) => ({
        ...row,
        line: Number(row.line),
        depth: Number(row.depth),
        length: Number(row.length),
        date: new Date(row.date + 'T00:00:00' + row.timezone),
        datetime: new Date(row.datetime),
      }));

      console.log('Loaded', commits.length, 'commits');

      // Step 1.2: Computing commit data
      const data = d3.group(commits, (d) => d.commit);
      
      const commitData = Array.from(data, ([commit, lines]) => {
        let first = lines[0];
        let { author, date, time, timezone, datetime } = first;
        let ret = {
          id: commit,
          author,
          date,
          time,
          timezone,
          datetime,
          hourFrac: datetime.getHours() + datetime.getMinutes() / 60,
          totalLines: lines.length,
        };

        // Like ret.lines = lines
        Object.defineProperty(ret, 'lines', {
          value: lines,
          enumerable: false,
        });

        return ret;
      });

      console.log('Computed', commitData.length, 'unique commits');

      // Step 1.3: Displaying the stats
      const stats = [
        {
          label: 'Total commits',
          value: commitData.length,
        },
        {
          label: 'Total lines',
          value: commits.length,
        },
        {
          label: 'Average lines per commit',
          value: d3.mean(commitData, (d) => d.totalLines).toFixed(1),
        },
        {
          label: 'Distinct authors',
          value: new Set(commitData.map((d) => d.author)).size,
        },
        {
          label: 'Files',
          value: new Set(commits.map((d) => d.file)).size,
        },
        {
          label: 'File types',
          value: new Set(commits.map((d) => d.type)).size,
        },
        {
          label: 'Commits per author',
          value: (() => {
            const byAuthor = d3.rollup(
              commitData,
              (v) => v.length,
              (d) => d.author
            );
            return Array.from(byAuthor, ([author, count]) => `${author}: ${count}`).join(', ');
          })(),
        },
        {
          label: 'Lines per file type',
          value: (() => {
            const byType = d3.rollup(
              commits,
              (v) => v.length,
              (d) => d.type
            );
            return Array.from(byType, ([type, count]) => `${type}: ${count}`).join(', ');
          })(),
        },
        {
          label: 'First commit',
          value: d3.min(commitData, (d) => d.datetime).toLocaleDateString(),
        },
        {
          label: 'Last commit',
          value: d3.max(commitData, (d) => d.datetime).toLocaleDateString(),
        },
      ];

      const statsContainer = document.getElementById('stats');
      for (const stat of stats) {
        const dt = document.createElement('dt');
        dt.textContent = stat.label;
        const dd = document.createElement('dd');
        dd.textContent = stat.value;
        statsContainer.appendChild(dt);
        statsContainer.appendChild(dd);
      }

      // Step 5.4: Declare global scales so they can be used in isCommitSelected
      let xScale, yScale;

      // Step 2: Visualizing time and day of commits in a scatterplot
      function renderScatterPlot(data) {
        const svg = d3.select('#commit-scatterplot');
        const width = 800;
        const height = 600;
        const margin = { top: 20, right: 20, bottom: 60, left: 80 };
        const plotWidth = width - margin.left - margin.right;
        const plotHeight = height - margin.top - margin.bottom;

        svg.attr('viewBox', `0 0 ${width} ${height}`);

        // Create scales - now updating global variables
        xScale = d3.scaleTime()
          .domain(d3.extent(data, d => d.datetime))
          .range([margin.left, width - margin.right])
          .nice();

        yScale = d3.scaleLinear()
          .domain([0, 24])
          .range([height - margin.bottom, margin.top]);

        // Step 4.1 & 4.2: Creating a radius scale with scaleSqrt for proper area perception
        const radiusScale = d3.scaleSqrt()
          .domain(d3.extent(data, d => d.totalLines))
          .range([2, 10]);

        // Step 2.1: Drawing the dots with variable radius
        const dots = svg.append('g')
          .attr('class', 'dots');

        dots.selectAll('circle')
          .data(data)
          .join('circle')
          .attr('cx', d => xScale(d.datetime))
          .attr('cy', d => yScale(d.hourFrac))
          .attr('r', d => radiusScale(d.totalLines))
          .attr('fill', 'steelblue')
          .attr('opacity', 0.6);

        // Step 2.2: Adding axes
        const xAxis = d3.axisBottom(xScale);
        const yAxis = d3.axisLeft(yScale);

        svg.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0, ${height - margin.bottom})`)
          .call(xAxis);

        svg.append('g')
          .attr('class', 'y-axis')
          .attr('transform', `translate(${margin.left}, 0)`)
          .call(yAxis);

        // Add axis labels
        svg.append('text')
          .attr('class', 'x-axis-label')
          .attr('text-anchor', 'middle')
          .attr('x', width / 2)
          .attr('y', height - 10)
          .text('Commit Date');

        svg.append('text')
          .attr('class', 'y-axis-label')
          .attr('text-anchor', 'middle')
          .attr('transform', `translate(15, ${height / 2}) rotate(-90)`)
          .text('Hour of Day');

        // Step 2.3: Adding horizontal grid lines
        svg.append('g')
          .attr('class', 'grid')
          .attr('transform', `translate(${margin.left}, 0)`)
          .call(d3.axisLeft(yScale)
            .tickSize(-(plotWidth))
            .tickFormat('')
          )
          .call(g => g.select('.domain').remove())
          .call(g => g.selectAll('.tick line')
            .attr('stroke', '#ccc')
            .attr('stroke-opacity', 0.3)
          );

        // Step 3: Adding tooltip functionality
        const tooltip = d3.select('#tooltip');

        // Step 3.3 & 3.4: Making tooltip appear on hover and positioning it
        svg.selectAll('circle')
          .on('mouseenter', function(event, d) {
            // Show and populate tooltip
            tooltip.style('display', 'block');
            
            document.getElementById('commit-id').textContent = d.id.substring(0, 7);
            document.getElementById('commit-author').textContent = d.author;
            document.getElementById('commit-date').textContent = d.datetime.toLocaleDateString();
            document.getElementById('commit-time').textContent = d.time;
            document.getElementById('commit-lines').textContent = d.totalLines;

            // Highlight the dot
            d3.select(this)
              .attr('fill', 'orange')
              .attr('opacity', 1);

            // Step 4.3: Raise the dot to the front for better interaction
            d3.select(this).raise();
          })
          .on('mousemove', function(event) {
            // Step 3.4: Position tooltip near cursor
            tooltip
              .style('left', (event.pageX + 10) + 'px')
              .style('top', (event.pageY + 10) + 'px');
          })
          .on('mouseleave', function(event, d) {
            // Hide tooltip
            tooltip.style('display', 'none');

            // Reset dot appearance
            d3.select(this)
              .attr('fill', 'steelblue')
              .attr('opacity', 0.6);
          });

        // Step 5.1: Setting up the brush
        svg.call(d3.brush().on('start brush end', brushed));

        // Step 5.2: Raise dots and everything after overlay
        svg.selectAll('.dots, .overlay ~ *').raise();
      }

      // Step 5.4: Function to check if a commit is selected
      function isCommitSelected(selection, commit) {
        if (!selection) {
          return false;
        }
        const [x0, x1] = selection.map((d) => d[0]);
        const [y0, y1] = selection.map((d) => d[1]);
        const x = xScale(commit.datetime);
        const y = yScale(commit.hourFrac);
        return x >= x0 && x <= x1 && y >= y0 && y <= y1;
      }

      // Step 5.5: Function to render selection count
      function renderSelectionCount(selection) {
        const selectedCommits = selection
          ? commitData.filter((d) => isCommitSelected(selection, d))
          : [];

        const countElement = document.querySelector('#selection-count');
        countElement.textContent = `${
          selectedCommits.length || 'No'
        } commits selected`;

        return selectedCommits;
      }

      // Step 5.6: Function to show language breakdown
      function renderLanguageBreakdown(selection) {
        const selectedCommits = selection
          ? commitData.filter((d) => isCommitSelected(selection, d))
          : [];
        const container = document.getElementById('language-breakdown');

        if (selectedCommits.length === 0) {
          container.innerHTML = '';
          return;
        }
        const requiredCommits = selectedCommits.length ? selectedCommits : commitData;
        const lines = requiredCommits.flatMap((d) => d.lines);

        // Use d3.rollup to count lines per language
        const breakdown = d3.rollup(
          lines,
          (v) => v.length,
          (d) => d.type,
        );

        // Update DOM with breakdown
        container.innerHTML = '';

        for (const [language, count] of breakdown) {
          const proportion = count / lines.length;
          const formatted = d3.format('.1~%')(proportion);

          container.innerHTML += `
            <dt>${language}</dt>
            <dd>${count} lines (${formatted})</dd>
          `;
        }
      }

      // Step 5.4: Brush event handler
      function brushed(event) {
        const selection = event.selection;
        if (selection) {
          d3.select('#commit-scatterplot')
            .selectAll('circle')
            .classed('selected', (d) => isCommitSelected(selection, d));
        } else {
          d3.select('#commit-scatterplot')
            .selectAll('circle')
            .classed('selected', false);
        }
        renderSelectionCount(selection);
        renderLanguageBreakdown(selection);
      }

      // Call the function to render the scatterplot
      renderScatterPlot(commitData);
    </script>
  </body>
</html>

