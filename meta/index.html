<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Meta - Code Analysis</title>
  </head>
  <body>
    <h1>Meta: Code Analysis</h1>
    <p>
      This page displays statistics and visualizations about the codebase of
      this portfolio website. The data is generated by analyzing git commit
      history and current code structure.
    </p>

    <h2>Summary Statistics</h2>
    <dl id="stats" class="stats"></dl>

    <div id="scrolly-1">
      <div id="scatter-story"></div>
      <div id="scatter-plot">
        <h2>Commit Timeline Scatterplot</h2>
        <svg id="commit-scatterplot"></svg>

        <div id="tooltip" class="info tooltip">
          <p>Commit: <strong id="commit-id"></strong></p>
          <p>Author: <strong id="commit-author"></strong></p>
          <p>Date: <strong id="commit-date"></strong></p>
          <p>Time: <strong id="commit-time"></strong></p>
          <p>Lines: <strong id="commit-lines"></strong></p>
        </div>

        <p id="selection-count">No commits selected</p>
        <dl id="language-breakdown" class="stats"></dl>

        <h3>Language Breakdown</h3>
        <div class="pie-chart-container">
          <svg id="language-pie"></svg>
          <div id="language-legend" class="pie-legend"></div>
        </div>
      </div>
    </div>

    <div id="scrolly-2">
      <div id="files-plot">
        <h2>File Sizes Evolution</h2>
        <dl id="files"></dl>
      </div>
      <div id="files-story"></div>
    </div>

    <link rel="stylesheet" href="../style.css" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="../global.js" type="module"></script>
    <script type="module">
      import { fetchJSON } from '../global.js';
      import scrollama from 'https://cdn.jsdelivr.net/npm/scrollama@3.2.0/+esm';

      // Step 1.1: Reading the CSV file in D3
      const commits = await d3.csv('loc.csv', (row) => ({
        ...row,
        line: Number(row.line),
        depth: Number(row.depth),
        length: Number(row.length),
        date: new Date(row.date + 'T00:00:00' + row.timezone),
        datetime: new Date(row.datetime),
      }));

      console.log('Loaded', commits.length, 'commits');

      // Step 1.2: Computing commit data
      const data = d3.group(commits, (d) => d.commit);

      const commitData = Array.from(data, ([commit, lines]) => {
        let first = lines[0];
        let { author, date, time, timezone, datetime } = first;
        let ret = {
          id: commit,
          author,
          date,
          time,
          timezone,
          datetime,
          hourFrac: datetime.getHours() + datetime.getMinutes() / 60,
          totalLines: lines.length,
        };

        // Like ret.lines = lines
        Object.defineProperty(ret, 'lines', {
          value: lines,
          enumerable: false,
        });

        return ret;
      });

      console.log('Computed', commitData.length, 'unique commits');

      // Step 1.3: Displaying the stats
      const stats = [
        {
          label: 'Total commits',
          value: commitData.length,
        },
        {
          label: 'Total lines',
          value: commits.length,
        },
        {
          label: 'Average lines per commit',
          value: d3.mean(commitData, (d) => d.totalLines).toFixed(1),
        },
        {
          label: 'Distinct authors',
          value: new Set(commitData.map((d) => d.author)).size,
        },
        {
          label: 'Files',
          value: new Set(commits.map((d) => d.file)).size,
        },
        {
          label: 'File types',
          value: new Set(commits.map((d) => d.type)).size,
        },
        {
          label: 'Commits per author',
          value: (() => {
            const byAuthor = d3.rollup(
              commitData,
              (v) => v.length,
              (d) => d.author
            );
            return Array.from(
              byAuthor,
              ([author, count]) => `${author}: ${count}`
            ).join(', ');
          })(),
        },
        {
          label: 'Lines per file type',
          value: (() => {
            const byType = d3.rollup(
              commits,
              (v) => v.length,
              (d) => d.type
            );
            return Array.from(
              byType,
              ([type, count]) => `${type}: ${count}`
            ).join(', ');
          })(),
        },
        {
          label: 'First commit',
          value: d3.min(commitData, (d) => d.datetime).toLocaleDateString(),
        },
        {
          label: 'Last commit',
          value: d3.max(commitData, (d) => d.datetime).toLocaleDateString(),
        },
      ];

      const statsContainer = document.getElementById('stats');
      for (const stat of stats) {
        const dt = document.createElement('dt');
        dt.textContent = stat.label;
        const dd = document.createElement('dd');
        dd.textContent = stat.value;
        statsContainer.appendChild(dt);
        statsContainer.appendChild(dd);
      }

      // Step 5.4: Declare global scales so they can be used in isCommitSelected
      let xScale, yScale;

      // Step 2.1: Create files array and render unit visualization
      let lines = commits;
      let files = d3
        .groups(lines, (d) => d.file)
        .map(([name, lines]) => {
          return { name, lines };
        })
        .sort((a, b) => b.lines.length - a.lines.length);

      // Step 2.4: Create color scale for technologies
      let colors = d3.scaleOrdinal(d3.schemeTableau10);

      // Step 2 & 4: Render files with better formatting and animations
      function renderFilesVisualization(filteredFiles) {
        const filesContainer = d3.select('#files');

        // Get all existing dt and dd elements
        const existingElements = filesContainer.selectAll('dt, dd').nodes();
        
        // Create a map of existing elements by file name
        const existingMap = new Map();
        existingElements.forEach(el => {
          if (el.tagName === 'DT') {
            const fileName = el.querySelector('.file-name')?.textContent;
            if (fileName) {
              existingMap.set(fileName, { dt: el, dd: null });
            }
          }
        });
        
        // Match dd elements to their dt
        existingElements.forEach(el => {
          if (el.tagName === 'DD') {
            const prevDt = el.previousElementSibling;
            if (prevDt && prevDt.tagName === 'DT') {
              const fileName = prevDt.querySelector('.file-name')?.textContent;
              if (fileName && existingMap.has(fileName)) {
                existingMap.get(fileName).dd = el;
              }
            }
          }
        });

        // Remove files that are no longer in the filtered list
        const filteredFileNames = new Set(filteredFiles.map(d => d.name));
        existingMap.forEach((elements, fileName) => {
          if (!filteredFileNames.has(fileName)) {
            if (elements.dt) {
              d3.select(elements.dt)
                .transition()
                .duration(500)
                .style('opacity', 0)
                .remove();
            }
            if (elements.dd) {
              d3.select(elements.dd)
                .transition()
                .duration(500)
                .style('opacity', 0)
                .remove();
            }
          }
        });

        // Add or update files
        filteredFiles.forEach((fileData) => {
          const existing = existingMap.get(fileData.name);
          
          if (existing && existing.dt) {
            // Update existing dt
            d3.select(existing.dt).html(`
              <span class="file-name">${fileData.name}</span>
              <span class="line-count">${fileData.lines.length} lines</span>
            `);
            
            // Update existing dd with dots
            if (existing.dd) {
              const dd = d3.select(existing.dd);
              dd.selectAll('.loc')
                .data(fileData.lines, (line) => `${fileData.name}-${line.line}`)
                .join(
                  (enter) =>
                    enter
                      .append('span')
                      .attr('class', 'loc')
                      .attr('style', (line) => `--color: ${colors(line.type)}`)
                      .style('opacity', 0)
                      .call((enter) =>
                        enter.transition().duration(300).style('opacity', 1)
                      ),
                  (update) => update,
                  (exit) =>
                    exit.call((exit) =>
                      exit.transition().duration(300).style('opacity', 0).remove()
                    )
                );
            }
          } else {
            // Create new dt
            const dt = filesContainer
              .append('dt')
              .style('opacity', 0)
              .html(`
                <span class="file-name">${fileData.name}</span>
                <span class="line-count">${fileData.lines.length} lines</span>
              `);
            
            // Create new dd immediately after dt
            const dd = filesContainer
              .append('dd')
              .style('opacity', 0);
            
            // Add dots to the new dd
            dd.selectAll('.loc')
              .data(fileData.lines)
              .enter()
              .append('span')
              .attr('class', 'loc')
              .attr('style', (line) => `--color: ${colors(line.type)}`);
            
            // Fade in the new elements
            dt.transition().duration(500).style('opacity', 1);
            dd.transition().duration(500).style('opacity', 1);
          }
        });
      }

      // Initial render with all files
      renderFilesVisualization(files);

      // Render pie chart for language breakdown
      function renderLanguagePieChart(data) {
        const svg = d3.select('#language-pie');
        const width = 300;
        const height = 300;
        const radius = Math.min(width, height) / 2;

        svg.attr('viewBox', `0 0 ${width} ${height}`);

        // Count lines by language
        const languageCounts = d3.rollup(
          data.flatMap((d) => d.lines),
          (v) => v.length,
          (d) => d.type
        );

        const pieData = Array.from(languageCounts, ([language, count]) => ({
          language,
          count,
        }));

        // Create pie and arc generators
        const pie = d3
          .pie()
          .value((d) => d.count)
          .sort(null);

        const arc = d3
          .arc()
          .innerRadius(0)
          .outerRadius(radius - 10);

        // Create group element centered
        const g = svg
          .selectAll('g')
          .data([null])
          .join('g')
          .attr('transform', `translate(${width / 2}, ${height / 2})`);

        // Create arcs
        const arcs = g
          .selectAll('.arc')
          .data(pie(pieData))
          .join('g')
          .attr('class', 'arc');

        arcs
          .selectAll('path')
          .data((d) => [d])
          .join('path')
          .attr('d', arc)
          .attr('fill', (d) => colors(d.data.language))
          .attr('stroke', 'white')
          .attr('stroke-width', 2);

        // Update legend instead of adding labels to the chart
        const legend = d3.select('#language-legend');
        legend
          .selectAll('.legend-item')
          .data(pieData)
          .join('div')
          .attr('class', 'legend-item')
          .html((d) => `
            <span class="legend-swatch" style="background-color: ${colors(d.language)}"></span>
            <span class="legend-label">${d.language} (${d.count} lines)</span>
          `);
      }

      // Initial render of pie chart
      renderLanguagePieChart(commitData);

      // Step 2: Visualizing time and day of commits in a scatterplot
      function renderScatterPlot(data) {
        const svg = d3.select('#commit-scatterplot');
        const width = 800;
        const height = 600;
        const margin = { top: 20, right: 20, bottom: 60, left: 80 };
        const plotWidth = width - margin.left - margin.right;
        const plotHeight = height - margin.top - margin.bottom;

        svg.attr('viewBox', `0 0 ${width} ${height}`);

        // Create scales - now updating global variables
        xScale = d3
          .scaleTime()
          .domain(d3.extent(data, (d) => d.datetime))
          .range([margin.left, width - margin.right])
          .nice();

        yScale = d3
          .scaleLinear()
          .domain([0, 24])
          .range([height - margin.bottom, margin.top]);

        // Step 4.1 & 4.2: Creating a radius scale with scaleSqrt for proper area perception
        const radiusScale = d3
          .scaleSqrt()
          .domain(d3.extent(data, (d) => d.totalLines))
          .range([2, 10]);

        // Step 2.1: Drawing the dots with variable radius
        const dots = svg.append('g').attr('class', 'dots');

        dots
          .selectAll('circle')
          .data(data)
          .join('circle')
          .attr('cx', (d) => xScale(d.datetime))
          .attr('cy', (d) => yScale(d.hourFrac))
          .attr('r', (d) => radiusScale(d.totalLines))
          .attr('fill', 'steelblue')
          .attr('opacity', 0.6);

        // Step 2.2: Adding axes
        const xAxis = d3.axisBottom(xScale);
        const yAxis = d3.axisLeft(yScale);

        svg
          .append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0, ${height - margin.bottom})`)
          .call(xAxis);

        svg
          .append('g')
          .attr('class', 'y-axis')
          .attr('transform', `translate(${margin.left}, 0)`)
          .call(yAxis);

        // Add axis labels
        svg
          .append('text')
          .attr('class', 'x-axis-label')
          .attr('text-anchor', 'middle')
          .attr('x', width / 2)
          .attr('y', height - 10)
          .text('Commit Date');

        svg
          .append('text')
          .attr('class', 'y-axis-label')
          .attr('text-anchor', 'middle')
          .attr('transform', `translate(15, ${height / 2}) rotate(-90)`)
          .text('Hour of Day');

        // Step 2.3: Adding horizontal grid lines
        svg
          .append('g')
          .attr('class', 'grid')
          .attr('transform', `translate(${margin.left}, 0)`)
          .call(d3.axisLeft(yScale).tickSize(-plotWidth).tickFormat(''))
          .call((g) => g.select('.domain').remove())
          .call((g) =>
            g
              .selectAll('.tick line')
              .attr('stroke', '#ccc')
              .attr('stroke-opacity', 0.3)
          );

        // Step 3: Adding tooltip functionality
        const tooltip = d3.select('#tooltip');

        // Step 3.3 & 3.4: Making tooltip appear on hover and positioning it
        svg
          .selectAll('circle')
          .on('mouseenter', function (event, d) {
            // Show and populate tooltip
            tooltip.style('display', 'block');

            document.getElementById('commit-id').textContent = d.id.substring(
              0,
              7
            );
            document.getElementById('commit-author').textContent = d.author;
            document.getElementById('commit-date').textContent =
              d.datetime.toLocaleDateString();
            document.getElementById('commit-time').textContent = d.time;
            document.getElementById('commit-lines').textContent = d.totalLines;

            // Highlight the dot
            d3.select(this).attr('fill', 'orange').attr('opacity', 1);

            // Step 4.3: Raise the dot to the front for better interaction
            d3.select(this).raise();
          })
          .on('mousemove', function (event) {
            // Step 3.4: Position tooltip near cursor
            tooltip
              .style('left', event.pageX + 10 + 'px')
              .style('top', event.pageY + 10 + 'px');
          })
          .on('mouseleave', function (event, d) {
            // Hide tooltip
            tooltip.style('display', 'none');

            // Reset dot appearance
            d3.select(this).attr('fill', 'steelblue').attr('opacity', 0.6);
          });

        // Step 5.1: Setting up the brush
        svg.call(d3.brush().on('start brush end', brushed));

        // Step 5.2: Raise dots and everything after overlay
        svg.selectAll('.dots, .overlay ~ *').raise();
      }

      // Step 1.2: Update scatter plot with filtered data
      function updateScatterPlot(data) {
        const svg = d3.select('#commit-scatterplot');
        const width = 800;
        const height = 600;
        const margin = { top: 20, right: 20, bottom: 60, left: 80 };

        // Update scales
        xScale = d3
          .scaleTime()
          .domain(d3.extent(commitData, (d) => d.datetime))
          .range([margin.left, width - margin.right])
          .nice();

        yScale = d3
          .scaleLinear()
          .domain([0, 24])
          .range([height - margin.bottom, margin.top]);

        const radiusScale = d3
          .scaleSqrt()
          .domain(d3.extent(commitData, (d) => d.totalLines))
          .range([2, 10]);

        // Update dots - Step 1.3: Using key function for stable transitions
        const dots = svg.select('.dots');
        const tooltip = d3.select('#tooltip');

        dots
          .selectAll('circle')
          .data(data, (d) => d.id)
          .join(
            (enter) =>
              enter
                .append('circle')
                .attr('cx', (d) => xScale(d.datetime))
                .attr('cy', (d) => yScale(d.hourFrac))
                .attr('r', 0)
                .attr('fill', 'steelblue')
                .attr('opacity', 0)
                .call((enter) =>
                  enter
                    .transition()
                    .duration(500)
                    .attr('r', (d) => radiusScale(d.totalLines))
                    .attr('opacity', 0.6)
                ),
            (update) =>
              update.call((update) =>
                update
                  .transition()
                  .duration(500)
                  .attr('cx', (d) => xScale(d.datetime))
                  .attr('cy', (d) => yScale(d.hourFrac))
                  .attr('r', (d) => radiusScale(d.totalLines))
              ),
            (exit) =>
              exit.call((exit) =>
                exit
                  .transition()
                  .duration(500)
                  .attr('r', 0)
                  .attr('opacity', 0)
                  .remove()
              )
          )
          .attr('cx', (d) => xScale(d.datetime))
          .attr('cy', (d) => yScale(d.hourFrac))
          .attr('r', (d) => radiusScale(d.totalLines))
          .attr('fill', 'steelblue')
          .attr('opacity', 0.6)
          .on('mouseenter', function (event, d) {
            tooltip.style('display', 'block');

            document.getElementById('commit-id').textContent = d.id.substring(
              0,
              7
            );
            document.getElementById('commit-author').textContent = d.author;
            document.getElementById('commit-date').textContent =
              d.datetime.toLocaleDateString();
            document.getElementById('commit-time').textContent = d.time;
            document.getElementById('commit-lines').textContent = d.totalLines;

            d3.select(this).attr('fill', 'orange').attr('opacity', 1);

            d3.select(this).raise();
          })
          .on('mousemove', function (event) {
            tooltip
              .style('left', event.pageX + 10 + 'px')
              .style('top', event.pageY + 10 + 'px');
          })
          .on('mouseleave', function (event, d) {
            tooltip.style('display', 'none');

            d3.select(this).attr('fill', 'steelblue').attr('opacity', 0.6);
          });

        // Update x-axis
        const xAxis = d3.axisBottom(xScale);
        svg.select('.x-axis').call(xAxis);
      }

      // Step 5.4: Function to check if a commit is selected
      function isCommitSelected(selection, commit) {
        if (!selection) {
          return false;
        }
        const [x0, x1] = selection.map((d) => d[0]);
        const [y0, y1] = selection.map((d) => d[1]);
        const x = xScale(commit.datetime);
        const y = yScale(commit.hourFrac);
        return x >= x0 && x <= x1 && y >= y0 && y <= y1;
      }

      // Step 5.5: Function to render selection count
      function renderSelectionCount(selection) {
        const selectedCommits = selection
          ? commitData.filter((d) => isCommitSelected(selection, d))
          : [];

        const countElement = document.querySelector('#selection-count');
        countElement.textContent = `${
          selectedCommits.length || 'No'
        } commits selected`;

        return selectedCommits;
      }

      // Step 5.6: Function to show language breakdown
      function renderLanguageBreakdown(selection) {
        const selectedCommits = selection
          ? commitData.filter((d) => isCommitSelected(selection, d))
          : [];
        const container = document.getElementById('language-breakdown');

        if (selectedCommits.length === 0) {
          container.innerHTML = '';
          return;
        }
        const requiredCommits = selectedCommits.length
          ? selectedCommits
          : commitData;
        const lines = requiredCommits.flatMap((d) => d.lines);

        // Use d3.rollup to count lines per language
        const breakdown = d3.rollup(
          lines,
          (v) => v.length,
          (d) => d.type
        );

        // Update DOM with breakdown
        container.innerHTML = '';

        for (const [language, count] of breakdown) {
          const proportion = count / lines.length;
          const formatted = d3.format('.1~%')(proportion);

          container.innerHTML += `
            <dt>${language}</dt>
            <dd>${count} lines (${formatted})</dd>
          `;
        }
      }

      // Step 5.4: Brush event handler
      function brushed(event) {
        const selection = event.selection;
        if (selection) {
          d3.select('#commit-scatterplot')
            .selectAll('circle')
            .classed('selected', (d) => isCommitSelected(selection, d));
        } else {
          d3.select('#commit-scatterplot')
            .selectAll('circle')
            .classed('selected', false);
        }
        renderSelectionCount(selection);
        renderLanguageBreakdown(selection);
      }

      // Call the function to render the scatterplot
      renderScatterPlot(commitData);

      // Step 3.2: Generate commit text for scrollytelling
      // Sort commitData by datetime for proper ordering
      const sortedCommitData = commitData
        .slice()
        .sort((a, b) => a.datetime - b.datetime);

      d3.select('#scatter-story')
        .selectAll('.step')
        .data(sortedCommitData)
        .join('div')
        .attr('class', 'step')
        .html(
          (d, i) => `
      On ${d.datetime.toLocaleString('en', {
        dateStyle: 'full',
        timeStyle: 'short',
      })},
      I made <a href="https://github.com/ShivUCSD1104/portfolio/commit/${
        d.id
      }" target="_blank">${
            i > 0
              ? 'another glorious commit'
              : 'my first commit, and it was glorious'
          }</a>.
      I edited ${d.totalLines} lines across ${
            d3.rollups(
              d.lines,
              (D) => D.length,
              (d) => d.file
            ).length
          } files.
      Then I looked over all I had made, and I saw that it was very good.
    `
        );

      // Step 3.3: Set up Scrollama for scrollytelling
      let commitMaxTime;
      let filteredCommits;

      function onStepEnter(response) {
        const commitDate = response.element.__data__.datetime;

        // Update commitMaxTime and filter commits
        commitMaxTime = commitDate;
        filteredCommits = sortedCommitData.filter(
          (d) => d.datetime <= commitMaxTime
        );

        // Update the scatter plot
        updateScatterPlot(filteredCommits);

        // Update the pie chart
        renderLanguagePieChart(filteredCommits);
      }

      const scroller = scrollama();
      scroller
        .setup({
          container: '#scrolly-1',
          step: '#scrolly-1 .step',
        })
        .onStepEnter(onStepEnter);

      // Step 4: Set up second scrollytelling for files
      d3.select('#files-story')
        .selectAll('.step')
        .data(sortedCommitData)
        .join('div')
        .attr('class', 'step')
        .html(
          (d, i) => `
      On ${d.datetime.toLocaleString('en', {
        dateStyle: 'full',
        timeStyle: 'short',
      })},
      I made <a href="https://github.com/ShivUCSD1104/portfolio/commit/${
        d.id
      }" target="_blank">${
            i > 0
              ? 'another glorious commit'
              : 'my first commit, and it was glorious'
          }</a>.
      I edited ${d.totalLines} lines across ${
            d3.rollups(
              d.lines,
              (D) => D.length,
              (d) => d.file
            ).length
          } files.
      Then I looked over all I had made, and I saw that it was very good.
    `
        );

      // Set up Scrollama for files section
      function onFilesStepEnter(response) {
        const commitDate = response.element.__data__.datetime;

        // Filter files based on commits up to this point
        const relevantCommits = sortedCommitData.filter(
          (d) => d.datetime <= commitDate
        );
        const relevantLines = relevantCommits.flatMap((c) => c.lines);

        // Group by file and count lines
        const currentFiles = d3
          .groups(relevantLines, (d) => d.file)
          .map(([name, lines]) => {
            return { name, lines };
          })
          .sort((a, b) => b.lines.length - a.lines.length);

        renderFilesVisualization(currentFiles);
      }

      const filesScroller = scrollama();
      filesScroller
        .setup({
          container: '#scrolly-2',
          step: '#scrolly-2 .step',
        })
        .onStepEnter(onFilesStepEnter);
    </script>
  </body>
</html>
